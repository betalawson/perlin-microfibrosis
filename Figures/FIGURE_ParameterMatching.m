function FIGURE_ParameterMatching
% This function generates the figure showing the results obtained after
% using SMC-ABC to match a pattern generated by a certain set of
% parameters. Three figures are created, because two are shown in the
% supplement.

% Define the plotting sizes (all as fractions of one)
margin_patterns = 0.065;
xsep = 0.05;
xgap_patterns = 0.005;
ygap_patterns = -0.125;

margin_params = 0.1;
y_layergap = 0.01;
xgap_params = 0.04;
ygap_params = 0.21;
leftTextSpace = 0;
titleSpace = 0;
bottomSpace = 0.03;

nrows_params = 2;
ncols_params = 4;

% Specify the number of generated patterns to show
n_show = 6;

% Define the parameters targetted
target_params = [
    [0.15, 0.75, 0.2, 0.7, 0.65, 3, 2.5, -pi/3];
    [0.36, 1.1, 0.05, 0.1, 0.3, 5, 1.2, pi/4];
    [0, 10, 0.4, 1.1, 0.9, 3, 3, pi/6];              % 10 is a dummy value because this parameter is irrelevant when f = 0
    ];

% Define the parameter ranges
params_mins = [ 0, 0.3, 0, 0.01, 0, 1, 1, -pi/2 ];
params_maxs = [ 0.4, 2, 0.5, 2, 0.99, 8, 50, pi/2 ];
scale_param = logical([ 0, 0, 0, 0, 0, 0, 1, 0]);

% Define the names of the parameters
param_names = {'Fibreness', 'Fibre Separation', 'Density Var.', 'Feature Size', 'Roughness', 'Density Var. Scale', 'Anisotropy', 'Fibre Direction'};
param_symbols = {'f', 'L', 'd', 'l_b', '\gamma', 'l_d', 'R', '\phi(^o)'};

% Specify the parameter ordering
param_ordering = [4, 5, 7, 8, 3, 6, 1, 2];

% Define the filenames of the matched patterns
particle_filenames = {'params12000_full', 'params32000_full', 'params22000_full'};

% Define the target density
target_density = 0.2;

% Define the pattern dimensions and pixel width
pixel_width = 1/136;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Switch up a level to the main folder to run code
cd ..

% Number of columns is one more than the number of patterns to show
n_cols = n_show + 1;

% The target_params vector defines the number of total parameters, and the
% number of parameter sets
[n_paramsets, n_params] = size(target_params);

% Transform the scale parameters into their logarithms
params_mins(scale_param) = log(params_mins(scale_param));
params_maxs(scale_param) = log(params_maxs(scale_param));
target_params_plot = target_params;
target_params_plot(:,scale_param) = log(target_params(:,scale_param));

% Also convert angles to degrees just to display nicer
params_mins(8) = params_mins(8) * 180/pi;
params_maxs(8) = params_maxs(8) * 180/pi;

% Append log to symbol text for scaling parameters
for k = find(scale_param)
    param_symbols{k} = ['\log\left(', param_symbols{k}, '\right)'];
end

patterncolors = {[0, 0, 1], [1, 0, 0], [0 0 0]};

% Define a 'fibrosis' colormap
fibro_clr = [[0.95, 0.85, 0.55]; [0.8, 0.2, 0.2]];

% Load up the seed information
load('fibro_seedinfo.mat', 'permute_tables', 'offset_tables');


% Calculate the derived plotting sizes:

% Patterns
dx_patterns = (1 - 2*margin_patterns - (n_cols - 1)*xgap_patterns - leftTextSpace - xsep) / n_cols;
dy_patterns = (1 - 2*margin_patterns - (n_paramsets - 1) * ygap_patterns - titleSpace - bottomSpace) / n_paramsets;
% Parameters
dx_params = (1 - 2*margin_params - (ncols_params - 1)*xgap_params - leftTextSpace) / ncols_params;
dy_params = (1 - 2*margin_params - (nrows_params - 1)*ygap_params - titleSpace) / (nrows_params);
dy_oneset = (dy_params - (n_paramsets - 1)*y_layergap) / n_paramsets;

% Initialise the figure and axes for the patterns plot
figure('units', 'normalized', 'OuterPosition', [0 0 1 1]);
for k = 1:n_paramsets
    
    % Specify the y position (consistent for all patterns corresponding to
    % this paramset
    ypos = 1 - margin_patterns - dy_patterns - (k-1) * (dy_patterns + ygap_patterns);
    
    % Axis for the target pattern
    xpos = margin_patterns + leftTextSpace;
    pattern_ax{k,1} = axes('Position', [xpos, ypos, dx_patterns, dy_patterns]);
    
    % Now loop across the displayed generated patterns, create their axes
    for j = 1:n_show
        xpos = margin_patterns + leftTextSpace + xsep + j * (dx_patterns + xgap_patterns);
        pattern_ax{k,j+1} = axes('Position', [xpos, ypos, dx_patterns, dy_patterns]);
    end
    
end

% Now display the target patterns and the generated patterns beside them
% using these axes
for k = 1:n_paramsets
    
    % Load the particles corresponding to this paramset (and store for
    % later)
    load(['Results\',particle_filenames{k}]);
    particlesets{k} = particles;
    
    % Read out the dimensions of the patterns
    [Ny, Nx] = size(particlesets{k}.vals{1});
    
    % Create the mesh for generating patterns of this size
    points = buildMesh(Nx, Ny, pixel_width);
    
    % (Re-)Generate the targetted pattern
    target_pattern = createFibroPattern(points, target_density, target_params(k,:), permute_tables{1}, offset_tables{1});
    
    % Now plot the target pattern
    imagesc(pattern_ax{k,1}, target_pattern);
    axis(pattern_ax{k,1}, 'equal', 'off');
    colormap(pattern_ax{k,1}, fibro_clr);
    
    % Convert angles to degrees now the radians value has been used to
    % rebuild the target pattern
    particlesets{k}.thetas(:,8) = particlesets{k}.thetas(:,8) * 180/pi;
    target_params_plot(k,8) = target_params_plot(k,8) * 180/pi;
    
    % Reduce the set of particles to only the unique particles using unique command
    [~, I] = unique(particlesets{k}.thetas, 'rows');
    particlesets{k}.vals = particlesets{k}.vals(I);
    particlesets{k}.Ds = particlesets{k}.Ds(I);
    
    % Sort the unique particles by their discrepancies
    [particlesets{k}.Ds, I] = sort(particlesets{k}.Ds);
    particlesets{k}.vals = particlesets{k}.vals(I);
    
    % Select particles corresponding to quantiles (to give even spread of
    % discrepancy values)
    quantiles = round(linspace(1,length(particlesets{k}.Ds),n_show));
    
    % Select these quantiles and plot them
    for j = 1:n_show
        
        imagesc(pattern_ax{k,j+1}, particles.vals{quantiles(j)});
        axis(pattern_ax{k,j+1}, 'equal', 'off');
        colormap(pattern_ax{k,j+1}, fibro_clr);
        
    end
    
    % Add labels for target and generated patterns above the top row
    if k == 1
        
        text(pattern_ax{k,1}, Nx/2, -Ny/6, 'Target Pattern', 'FontSize', 28, 'HorizontalAlignment', 'Center');
        text(pattern_ax{k,ceil((n_show+1)/2)}, Nx*1.1, -Ny/6, 'Generated', 'FontSize', 28, 'HorizontalAlignment', 'Center');
        
    end
    
    % Also add a pattern number on the left of the target patterns
    text(pattern_ax{k,1}, -Nx/6, Ny/2, num2str(k), 'HorizontalAlignment', 'Right', 'FontSize', 28, 'Color', patterncolors{k});
    
end

text(pattern_ax{n_paramsets,2}, Nx/2, Ny*5/4, {'Minimum','Discrepancy'}, 'FontSize', 24, 'HorizontalAlignment', 'center');
text(pattern_ax{n_paramsets,n_show+1}, Nx/2, Ny*5/4, {'Maximum','Discrepancy'}, 'FontSize', 24, 'HorizontalAlignment', 'center');
annotation('textarrow',[0.330 0.830],[0.125 0.125]);


% Initialise a figure and its axes. Under this idea, all pattern marginals
% are plotted on the same "axis" but layered vertically. So, the real axes
% assigned to each individual graph is only a fraction of the full
figure('units', 'normalized', 'OuterPosition', [0 0 1 1]);
for k = 1:n_paramsets
    for i = 1:nrows_params
        for j = 1:ncols_params
            
            % Specify the axis positions and create it
            xpos = margin_params + leftTextSpace + (j-1) * (dx_params + xgap_params);
            ypos = 1 - margin_params - k * dy_oneset - (k-1) * y_layergap - (i-1) * (dy_params + ygap_params);
            params_ax{i,j,k} = axes('Position', [xpos, ypos, dx_params, dy_oneset]);
            
        end
    end
end

% Now loop over the different parameter sets, plotting marginal
% distributions as different colours
for k = 1:n_paramsets
    
    % Loop over parameters, calculating marginal for this parameter (in
    % this parameter set), and then plotting both marginal and actual value
    for i = 1:nrows_params
        for j = 1:ncols_params
            
            % Convert row and column position to parameter number (applying re-ordering)
            cp = param_ordering((i-1)*ncols_params + j);
            
            % Use ksdensity to plot the distribution of parameter values
            [f, x] = ksdensity(particlesets{k}.thetas(:,cp), linspace(params_mins(cp), params_maxs(cp), 500)' );
            
            % Store the maximum value (to help with y limits)
            maxval = max(f);
            
            % Set hold on so that marginal and actual value can both be
            % plotted
            hold(params_ax{i,j, k},'on');
            
            % Plot the marginal distribution
            plot(params_ax{i,j,k}, x, f, 'LineWidth', 2, 'Color', patterncolors{k});
            
            % Plot a vertical dotted line for the actual parameter value
            plot(params_ax{i,j,k}, [target_params_plot(k,cp) target_params_plot(k,cp)], [0, 1.5*maxval], '--', 'Color', patterncolors{k}, 'LineWidth', 2);
            
            % Set axis limits
            xlim(params_ax{i,j,k}, [params_mins(cp) params_maxs(cp)]);
            ylim(params_ax{i,j,k}, [0.001*maxval 1.1*maxval]);
            
            % Add a parameter name on top (so, only if working on the first
            % parameter set)
            if k == 1
                text(params_ax{i,j,k}, (params_mins(cp)+params_maxs(cp))/2, 1.5*maxval, param_names{cp}, 'HorizontalAlignment', 'Center', 'FontSize', 20);
            end
            
            % Set axis labels on bottom (so, only if working on the last
            % parameter set). Also set fontsize for numerical labels
            if k == n_paramsets
                xlabel(params_ax{i,j,k}, ['$$',param_symbols{cp},'$$'], 'Interpreter', 'latex', 'Fontsize', 24);
                set(params_ax{i,j,k}, 'FontSize', 18);
                params_ax{i,j,k}.YAxis.Visible = 'off';
                set(params_ax{i,j,k},'Color',[1 1 1]);
            else     % Otherwise, turn off labels and axes
                set(params_ax{i,j,k},'XTickLabels',[]);
                axis(params_ax{i,j,k}, 'off');
            end
            
            % y-axis labels are always turned off
            set(params_ax{i,j,k},'YTickLabels',[]);
            set(params_ax{i,j,k},'YTick',[]);
            
        end
    end
    
end

% Now create bivariate scatter plots for each particle set separately
for k = 1:length(particlesets)
   
    % Create a new figure
    figure('units','Normalized','OuterPosition',[0 0 1 1]);
    
    % Loop over the different parameter combinations (hard-coded to 8
    % parameters for simplicity)
    c = 0;
    for i = 1:7
        for j = i+1:8
    
            % Increment counter
            c = c + 1;
            
            % Just use subplots here for a supplementary figure
            subplot(4,7,c);
            
            % Read out the two parameters to plot (using given ordering)
            param1 = param_ordering(i);
            param2 = param_ordering(j);
            
            % Plot the bivariate scatter for this parameter pair
            plot( particlesets{k}.thetas(:,param1), particlesets{k}.thetas(:,param2), '.', 'Markersize', 20, 'MarkerEdgeColor', patterncolors{k} );
            
            % Add labels
            xlabel(['$$',param_symbols{param1},'$$'],'Fontsize',20,'Interpreter','latex');
            ylabel(['$$',param_symbols{param2},'$$'],'Fontsize',20,'Interpreter','latex');
            
            % Set axis to parameter limits
            xlim([params_mins(param1), params_maxs(param1)]);
            ylim([params_mins(param2), params_maxs(param2)]);
            
        end
    end
            
end

% Return to figures folder
cd Figures